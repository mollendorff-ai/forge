[package]
name = "royalbit-forge"
version = "9.7.0"
edition = "2021"
authors = ["Claude (Opus 4.5) - Principal Autonomous AI <noreply@anthropic.com>", "RoyalBit Inc. <admin@royalbit.ca>"]
description = "A Self-Evolving Autonomous AI project. YAML formula calculator with 60+ Excel functions, 96K rows/sec. Created with RoyalBit Asimov."
repository = "https://github.com/royalbit/forge"
homepage = "https://github.com/royalbit/forge"
documentation = "https://github.com/royalbit/forge#readme"
license-file = "LICENSE"
publish = false
keywords = ["yaml", "formula", "excel", "asimov", "ai-built"]
categories = ["command-line-utilities", "parsing", "development-tools"]
readme = "README.md"
exclude = [
    "test-data/*",
    ".git*",
]

# Demo binary (47 scalar functions, no servers, v1.0.0 schema only)
# Build: cargo build --release --features demo
[[bin]]
name = "forge-demo"
path = "src/main.rs"
required-features = ["demo"]

# Enterprise binary (173 functions, all features)
# Build: cargo build --release
[[bin]]
name = "forge"
path = "src/main.rs"

# Enterprise MCP server (AI integration)
[[bin]]
name = "forge-mcp"
path = "src/bin/forge_mcp.rs"

# Enterprise API server (REST API)
[[bin]]
name = "forge-server"
path = "src/bin/forge_server.rs"

[dependencies]
# YAML parsing
serde = { version = "1.0", features = ["derive"] }
serde_yaml_ng = "0.10"
serde_json = "1.0"  # JSON handling for schema validation

# Expression evaluation (Excel-compatible formulas)
xlformula_engine = "0.1.18"

# JSON Schema validation (v1.0.0 array model)
jsonschema = "0.37"

# CLI
clap = { version = "4.5.53", features = ["derive", "env"] }

# Error handling
anyhow = "1.0"
thiserror = "2.0"

# Dependency graph (for formula ordering)
petgraph = "0.8"

# Regex for array indexing preprocessing
regex = "1.12"

# Pretty output
colored = "3.0"

# Excel export (v1.0.0 array model)
rust_xlsxwriter = "0.92"

# Excel import (v1.0.0 array model)
calamine = "0.32"

# File watching (v1.4.0 watch mode)
notify = "8.2"
notify-debouncer-mini = "0.7"

# Async runtime (API server, MCP server)
tokio = { version = "1", features = ["rt-multi-thread", "macros", "io-std", "signal", "net"] }
async-trait = "0.1"

# API Server (v2.0.0 - enterprise HTTP API)
axum = "0.8"
tower = { version = "0.5", features = ["util"] }
tower-http = { version = "0.6", features = ["cors", "trace"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
uuid = { version = "1.0", features = ["v4"] }
chrono = { version = "0.4", features = ["serde"] }
rand = "0.9.2"

# Monte Carlo simulation (enterprise only)
rand_distr = "0.5"  # Distribution sampling (Normal, Triangular, PERT, etc.)
statrs = "0.18"     # Statistical functions (PDF, CDF, percentiles)

[features]
default = []

# Enterprise build (default) - includes all 173 functions, API server, Monte Carlo, etc.
# Demo build: ~47 functions, v1.0.0 schema only, no API server
# Build commands:
#   cargo build --release                   # Enterprise binary (full)
#   cargo build --release --features demo   # Demo binary (restricted)
demo = []

# Backward compatibility alias (deprecated - use default build for enterprise)
full = []

# E2E tests migrated to forge-e2e repository (see ADR-027)
# Gnumeric, R, Python validation now in https://github.com/royalbit/forge-e2e

[dev-dependencies]
# Testing
pretty_assertions = "1.4"
tempfile = "3.8"
assert_cmd = "2.0"  # CLI integration testing
predicates = "3.1"  # CLI output assertions
# Git hooks (auto-installs on cargo test)
cargo-husky = { version = "1", default-features = false, features = ["user-hooks"] }

# Allow coverage and feature cfgs for conditional compilation (ADR-006, ADR-012)
[lints.rust]
unexpected_cfgs = { level = "warn", check-cfg = ['cfg(coverage)', 'cfg(feature, values("full"))'] }

# Pedantic linting - code is for humans to read (ADR-004)
[lints.clippy]
# Enable pedantic lints as warnings (fix them all!)
pedantic = { level = "warn", priority = -1 }

# Specific lints we enforce (auto-fixable)
redundant_closure_for_method_calls = "warn"
manual_string_new = "warn"
inefficient_to_string = "warn"
implicit_clone = "warn"
uninlined_format_args = "warn"

# Allow lints that would require significant refactoring
needless_pass_by_value = "allow"        # Too many to fix, minimal benefit
trivially_copy_pass_by_ref = "allow"    # Same
format_push_string = "allow"            # format! append is readable
assigning_clones = "allow"              # Clone assignment is fine
many_single_char_names = "allow"        # Math code uses x, y, z, etc.
redundant_else = "allow"                # Explicit else is clearer
needless_continue = "allow"             # Explicit continue is fine
option_if_let_else = "allow"            # Style preference
ref_option = "allow"                    # &Option<T> is fine for internal APIs
unused_self = "allow"                   # Methods with unused self for future use
return_self_not_must_use = "allow"      # Builder pattern doesn't need #[must_use]
if_then_some_else_none = "allow"        # bool.then() is less readable
case_sensitive_file_extension_comparisons = "allow" # We control extensions
implicit_hasher = "allow"               # HashMap<K,V> is fine, don't need generic hasher
match_wildcard_for_single_variants = "allow" # Explicit match is clearer
no_effect_underscore_binding = "allow"  # _ = expr is fine for side effects
manual_let_else = "allow"               # if let is more readable than let...else

# Allow some pedantic lints that are too noisy or conflict with our style
must_use_candidate = "allow"           # Too noisy for internal code
missing_docs_in_private_items = "allow" # We document public APIs only
module_name_repetitions = "allow"       # e.g., ForgeError in forge::error is fine
similar_names = "allow"                 # idx/idx2 is fine in loops
too_many_lines = "allow"                # Some functions are legitimately long
struct_excessive_bools = "allow"        # Config structs need many bools
fn_params_excessive_bools = "allow"     # Same for function params
cast_precision_loss = "allow"           # f64 to f32 is intentional
cast_possible_truncation = "allow"      # We handle truncation explicitly
cast_sign_loss = "allow"                # We handle sign explicitly
cast_possible_wrap = "allow"            # We handle wrap explicitly
if_not_else = "allow"                   # Style preference
match_same_arms = "allow"               # Sometimes clearer to be explicit
single_match_else = "allow"             # Style preference
struct_field_names = "allow"            # We use clear field names
wildcard_imports = "allow"              # We use prelude patterns
float_cmp = "allow"                     # We use epsilon comparisons where needed
items_after_statements = "allow"        # Test modules at end of impl blocks is fine
unreadable_literal = "allow"            # Long numbers are readable as-is (test data)
missing_errors_doc = "allow"            # Internal code doesn't need # Errors
missing_panics_doc = "allow"            # Internal code doesn't need # Panics
doc_markdown = "allow"                  # Too strict for doc comments
unnecessary_wraps = "allow"             # Result returns are fine for consistency
cast_lossless = "allow"                 # We control our casts explicitly

[profile.release]
# Optimize for size and performance
opt-level = 3
lto = true
codegen-units = 1
strip = true
panic = "abort"
